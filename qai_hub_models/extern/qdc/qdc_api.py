# ---------------------------------------------------------------------
# Copyright (c) 2025 Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause
# ---------------------------------------------------------------------
# FILE: NOT GENERATED BY AI HUB MODELS CONTRIBUTORS
# This file is downloaded along with QDC Python wheel.
# Any changes made to this file will be lost when the wheel is updated.
from __future__ import annotations

import json
import os
import sys
import uuid

import requests
from qdc_public_api_client import AuthenticatedClient, Client
from qdc_public_api_client.api.artifacts import (
    post_artifacts_startupload,
    post_artifacts_upload,
    post_artifacts_uuid_continueupload,
    post_artifacts_uuid_endupload,
)
from qdc_public_api_client.api.jobs import (
    get_jobs,
    get_jobs_downloadlogs,
    get_jobs_id,
    get_jobs_job_id_logs,
    post_jobs,
    post_jobs_job_id_abort,
)
from qdc_public_api_client.api.sessions import (
    get_sessions,
    get_sessions_session_id,
    post_sessions,
    post_sessions_session_id_complete,
)
from qdc_public_api_client.api.targets import targets_get
from qdc_public_api_client.models import CreateJobType0, CreateSessionType0, SessionMode
from qdc_public_api_client.models.post_artifacts_upload_body import (
    PostArtifactsUploadBody,
)
from qdc_public_api_client.types import File

"""Utils : provides the high methods for public api
    * getting public api client
    * uploading file
    * getting target
    * submitting job
    * monitoring job
    * querying the submitted jobs list
    * aborting the job
"""

# Constants
CHUNK_SIZE = 8388608  # ~ 8 MB in binary bytes
"""Chunk size for uploading larger files."""

# Job submissions fail if name is longer
QDC_JOB_NAME_LIMIT = 32

ACCESS_TOKEN_URL = (
    "https://apigwx-aws.qualcomm.com/saga/oauth/v1/token?grant_type=client_credentials"
)
"""Url to acquire the access tokens which is used for creation of qdc api client object."""

API_BASE_URL = "https://apigwx-aws.qualcomm.com/saga/v1/public/qdc"
"""Qdc api base url to create a client object."""


def get_public_api_client(
    client_id, client_secret, app_name_header, on_behalf_of_header, client_type_header
):
    """
    Description
    -----------
        Method 1, To get the client object of QDC Api using client id and client secret.
    Args
    ----
        client_id: Please request client id by contacting QDC Support.
        client_secret: Please request client id by contacting QDC Support.
        app_name_header: Name of the Client.
        on_behalf_of_header: Name of the user who is initiating the request.
        client_type_header: Client code type connecting to QDC Api.

    Returns
    -------
        object: Authenticated client object.
        None: In case of an failure.
    Usages
    ------
        # Please request client id/secret through QDC team
        client_id = ""
        client_secret = ""
        appname = "ai hub"
        on_behalf_of = "user_name"
        client_type = "Python"
        # qdc_api is the name of the module
        public_api_client = qdc_api.get_public_api_client(client_id, client_secret, appname, on_behalf_of, client_type)
    """
    response = requests.post(ACCESS_TOKEN_URL, auth=(client_id, client_secret))
    if response.status_code == 200:
        token = json.loads(response.text)["access_token"]
        print(f"Token acquired: {token}")
    else:
        print(f"Failed to acquire token: {response.text}")
        sys.exit()

    # Below headers are mandatory for now, please set X-QCOM-OnBehalfOf and  X-QCOM-TracingId accordingly
    qdc_headers = {
        "X-QCOM-TokenType": "OAuth",
        "X-QCOM-ClientId": client_id,
        "X-QCOM-AppName": app_name_header,
        "X-QCOM-OnBehalfOf": on_behalf_of_header,
        "X-QCOM-ClientType": client_type_header,
    }

    # Create the client using access token
    return AuthenticatedClient(base_url=API_BASE_URL, headers=qdc_headers, token=token)


def get_public_api_client_using_api_key(
    app_name_header, client_type_header, api_key_header
):
    """
    Description
    -----------
        Method 2, To get the client object of QDC Api using api key.

    Args
    ----
        app_name_header: Name of the Client.
        client_type_header: Client code type connecting to QDC Api.
        api_key_header: Get the api key from the QDC UI -> Users -> settings -> API Keys

    Returns
    -------
        object: Authenticated client object.
        None: In case of an failure.

    Usages
    ------
        app_name = "ai hub"
        client_type = "Python"
        # Please get the api key from the QDC UI -> Users -> settings -> API Keys
        api_key = ""

        # qdc_api is the name of the module
        public_api_client = qdc_api.get_public_api_client_using_api_key(app_name, client_type, api_key)
    """
    # Below headers are mandatory for now, please set X-QCOM-OnBehalfOf accordingly
    qdc_headers = {
        "Authorization": api_key_header,
        "X-QCOM-TokenType": "apikey",
        "X-QCOM-AppName": app_name_header,
        "X-QCOM-ClientType": client_type_header,
    }

    # Create the client using access token
    return Client(base_url=API_BASE_URL, headers=qdc_headers)


def upload_file(public_api_client, file_path, artifact_type):
    r"""
    Description
    -----------
        High level wrapper function to upload artifact.
        It checks to upload file in chunks or not based on the size.

    Args
    ----
        public_api_client: QDC api client object.
        file_path: Local path of the artifact to be uploaded.
        artifact_type: Type of the artifact (TESTPACKAGE, TESTSCRIPT).

    Returns
    -------
        uuid: uuid of the uploaded artifact.
        None: In case of any failure.

    Usages
    ------
        apk_file_to_upload = "C:\\Temp\\test.apk"

        # qdc_api is the name of the module
        apk_uuid = qdc_api.upload_file(public_api_client, apk_file_to_upload, ArtifactType.TESTPACKAGE)
    """
    if check_file_exists(file_path):
        file_size = get_file_size(file_path)
        file_name = get_filename(file_path)
        public_api_client = _get_client_with_new_trace_header(public_api_client)
        print(
            f"start uploading file:{file_name}, path:{file_path}, type:{artifact_type}, size:{file_size} bytes"
        )
        if file_size < CHUNK_SIZE:
            uuid = single_upload(public_api_client, file_path, file_name, artifact_type)
            if uuid is not None:
                print(f"successfully uploaded file, uuid:{uuid}")
                return uuid
            print("failed to upload file")
        else:
            print("starting chunk upload for large file")
            uuid = start_upload(public_api_client, file_name, artifact_type)
            if uuid is not None:
                print(f"successfully started chunk upload, uuid:{uuid}")
                if continue_upload(
                    public_api_client, uuid, file_path, file_name, artifact_type
                ):
                    print("successfully uploaded all chunks")
                    if end_upload(public_api_client, uuid):
                        print("successfully ended chunks upload")
                        return uuid
                    print("failed to end chunks upload")
                else:
                    print("failed to upload chunk")
            else:
                print("failed to start chunk upload")
    else:
        print(f"file path does not exists {file_path}, exiting...")
    return None


def check_file_exists(file_path):
    """
    Description
    -----------
        Method to check if file exists or not.

    Args
    ----
        file_path: path of the file.

    Returns
    -------
        true: if file exists.
        false: if file doesn't exist.

    Usages
    ------
        if check_file_exists(file_path):
            #DoSometing
    """
    return os.path.isfile(file_path)


def get_file_size(file_path):
    """
    Description
    -----------
        Method to check size of the file.

    Args
    ----
        file_path: path of the file.

    Returns
    -------
        bytes: size of the file.

    Usages
    ------
        file_size = get_file_size(file_path)
    """
    return os.path.getsize(file_path)


def get_filename(file_path):
    """
    Description
    -----------
        Method to get name of the file from path.

    Args
    ----
        file_path: path of the file.

    Returns
    -------
        string: name of the file

    Usages
    ------
        file_name = get_filename(file_path)
    """
    return os.path.basename(file_path)


def start_upload(public_api_client, file_name, artifact_type) -> str | None:
    r"""
    Description
    -----------
        To initiate upload of artifacts in chunks.
        (must be used of file size is greater than 10 MB).

    Args
    ----
        public_api_client: QDC api client object.
        file_name: Name of the artifact to be uploaded.
        artifact_type: Type of the artifact (TESTPACKAGE, TESTSCRIPT).

    Returns
    -------
        uuid: uuid of the uploaded artifact.
        None: In case of any failure.

    Usages
    ------
        file_name = "C:\\Temp\\test.apk"
        artifact_type = ArtifactType.TESTPACKAGE

        uuid = start_upload(public_api_client, file_name, artifact_type)
    """
    artifact_start_upload_response = post_artifacts_startupload.sync_detailed(
        client=public_api_client, filename=file_name, artifact_type=artifact_type
    )
    if artifact_start_upload_response.status_code == 200:
        print(
            f"start upload response: {artifact_start_upload_response.content.decode('utf-8')}"
        )
        assert (
            artifact_start_upload_response.parsed is not None
            and hasattr(artifact_start_upload_response.parsed, "uuid")
            and isinstance(artifact_start_upload_response.parsed.uuid, str)
        )
        return artifact_start_upload_response.parsed.uuid
    print(
        f"upload artifact failed with error code {artifact_start_upload_response.status_code} {artifact_start_upload_response.content.decode('utf-8')}"
    )
    return None


def continue_upload(public_api_client, uuid, file_path, file_name, artifact_type):
    r"""
    Description
    -----------
        To upload artifacts in chunks (greater than 10 MB),
        chunk size is a constant having value ~ 8 MB.

    Args
    ----
        public_api_client: QDC api client object.
        uuid: uuid of the initiated start upload request.
        file_path: Local path of the artifact to be uploaded.
        file_name: Name of the artifact to be uploaded.
        artifact_type: Type of the artifact (TESTPACKAGE, TESTSCRIPT).

    Returns
    -------
        uuid: uuid of the uploaded artifact.
        None: In case of any failure.

    Usages
    ------
        file_path = "C:\\Temp\\test.apk"
        file_name = get_filename(file_path)
        artifact_type = ArtifactType.TESTPACKAGE
        uuid = start_upload(public_api_client, file_name, artifact_type)

        continue_upload(public_api_client, uuid, file_path, file_name, artifact_type)
    """
    parts = 1
    offset = 0
    with open(file_path, "rb") as file:
        while True:
            chunk_data = file.read(CHUNK_SIZE)
            if not chunk_data:
                break
            print(
                f"uploading file:{file_name}, type:{artifact_type}, part:{parts}, size:{CHUNK_SIZE}, offset:{offset}"
            )
            artifact_continue_upload_response = (
                post_artifacts_uuid_continueupload.sync_detailed(
                    uuid=uuid,
                    body=PostArtifactsUploadBody(file=File(chunk_data, file_name)),
                    client=public_api_client,
                    offset=offset,
                    part=parts,
                    size=CHUNK_SIZE,
                )
            )
            offset = offset + CHUNK_SIZE
            parts = parts + 1
            if artifact_continue_upload_response.status_code == 200:
                print(
                    f"start upload response: {artifact_continue_upload_response.content.decode('utf-8')}"
                )
            else:
                print(
                    f"upload artifact failed with error code {artifact_continue_upload_response.status_code} {artifact_continue_upload_response.content.decode('utf-8')}"
                )
                return False
    return True


def end_upload(public_api_client, uuid):
    r"""
    Description
    -----------
        To finish artifacts upload.

    Args
    ----
        public_api_client: QDC api client object.
        uuid: uuid of the initiated start upload request.

    Returns
    -------
        true: If the upload is finished.
        false: If failed to finish the upload.

    Usages
    ------
        file_path = "C:\\Temp\\test.apk"
        file_name = get_filename(file_path)
        artifact_type = ArtifactType.TESTPACKAGE

        uuid = start_upload(public_api_client, file_name, artifact_type)
        continue_upload(public_api_client, uuid, file_path, file_name, artifact_type)

        end_upload(public_api_client, uuid)
    """
    artifact_upload_end_response = post_artifacts_uuid_endupload.sync_detailed(
        uuid=uuid, client=public_api_client
    )
    if artifact_upload_end_response.status_code == 200:
        print(
            f"Complete upload response: {artifact_upload_end_response.content.decode('utf-8')}"
        )
        return True
    print(
        f"Upload artifact failed with error code {artifact_upload_end_response.status_code} {artifact_upload_end_response.content.decode('utf-8')}"
    )
    return False


def single_upload(public_api_client, file_path, file_name, artifact_type):
    r"""
    Description
    -----------
        To upload artifact smaller in one go (less than 10 MB).

    Args
    ----
        public_api_client: QDC api client object.
        file_path: Local path of the artifact to be uploaded.
        file_name: Name of the artifact to be uploaded.
        artifact_type: Type of the artifact (TESTPACKAGE, TESTSCRIPT).

    Returns
    -------
        uuid: uuid of the uploaded artifact.
        None: In case of any failure.

    Usages
    ------
        file_path = "C:\\Temp\\test.apk"
        file_name = get_filename(file_path)
        artifact_type = ArtifactType.TESTPACKAGE

        uuid = single_upload(public_api_client, file_path, file_name, artifact_type)
    """
    with open(file_path, "rb") as file:
        while True:
            data = file.read()
            artifact_upload_response = post_artifacts_upload.sync_detailed(
                client=public_api_client,
                body=PostArtifactsUploadBody(file=File(data, file_name)),
                filename=file_name,
                artifact_type=artifact_type,
            )

            if artifact_upload_response.status_code == 200:
                print(
                    f"Upload response: {artifact_upload_response.content.decode('utf-8')}"
                )
                assert artifact_upload_response.parsed is not None and hasattr(
                    artifact_upload_response.parsed, "uuid"
                )
                return artifact_upload_response.parsed.uuid
            print(
                f"Upload artifact failed with error code {artifact_upload_response.status_code} {artifact_upload_response.content.decode('utf-8')}"
            )
            return None


def get_job_log_files(public_api_client, job_id):
    """
     Description
    -----------
        To get the list of log files for a given job id.

    Parameters
    ----------
        public_api_client: QDC api client object.
        job_id: id of the job

    Returns
    -------
        json object: object having filename and file size in bytes

    Usages
    ------
        job_id = 4309 ## job id for getting list of log files.
        logFiles = qdc_api.get_job_log_files(public_api_client, job_id)
    """
    job_logs_response = get_jobs_job_id_logs.sync_detailed(
        job_id=job_id, client=_get_client_with_new_trace_header(public_api_client)
    )
    if job_logs_response.status_code == 200:
        print(f"job logs response: {job_logs_response.content.decode('utf-8')}")
        assert job_logs_response.parsed is not None and isinstance(
            job_logs_response.parsed, list
        )
        for log_file in job_logs_response.parsed:
            assert (
                log_file is not None
                and hasattr(log_file, "filename")
                and hasattr(log_file, "file_size_in_byte")
            )
            print(
                f"filename: {log_file.filename}, size_in_bytes: {log_file.file_size_in_byte}"
            )
        return job_logs_response.parsed
    print(
        f"Get list of job logs failed with error code {job_logs_response.status_code} {job_logs_response.content.decode('utf-8')}"
    )
    return None


def download_job_log_files(public_api_client, file_path, local_zip_file):
    r"""
    Description
    -----------
        To download the job log file in .zip format

    Args
    ----
        public_api_client: QDC api client object.
        file_path: file path to download returned by get_job_log_files API.
        local_zip_file: local path where to download the file.

    Returns
    -------
        True: if download is success
        None: In case of failure.

    Usages
    ------
        qdc_api.download_job_log_files(public_api_client, "file path to download returned by get_job_log_files API", "c:\\temp\\file.zip")
    """
    download_job_log_response = get_jobs_downloadlogs.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client), path=file_path
    )
    if download_job_log_response.status_code == 200:
        print(f"download job logs success: {file_path} to {local_zip_file}")
        with open(local_zip_file, "wb") as f:
            # Write the byte content to the file
            f.write(download_job_log_response.content)
        return True
    print(f"download job logs file failed: {file_path}")
    return None


def get_target_id(public_api_client, target_name):
    """
    Description
    -----------
        To get the target id of a given chipset.

    Args
    ----
        public_api_client: QDC api client object.
        target_name: Name of the chipset.

    Returns
    -------
        int: ID of the given chipset.
        None: In case of failure.

    Usages
    ------
        target = "SC8280XP"

        target_id = qdc_api.get_target_id(public_api_client, target)
    """
    target_id = None
    # Get list of targets
    targets_response = targets_get.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client), page_size=200
    )
    if targets_response.status_code == 200:
        assert (
            targets_response.parsed is not None
            and hasattr(targets_response.parsed, "data")
            and targets_response.parsed.data is not None
            and isinstance(targets_response.parsed.data, list)
            and hasattr(targets_response.parsed, "total")
            and hasattr(targets_response.parsed, "page_number")
        )
        print(
            f"Target list: Received {len(targets_response.parsed.data)} of {targets_response.parsed.total} targets (page {targets_response.parsed.page_number})"
        )
        for target in targets_response.parsed.data:
            assert target is not None
            print(
                f"TargetId: {target.target_id}, ChipsetName: {target.chipset_name}, ChipsetMarketingName: {target.chipset_marketing_name}, "
                f"ChipsetPlatform {target.chipset_platform_name}, ChipsetCategory: {target.chipset_category}, OS: {target.os}, "
                f"OSVersion: {target.os_version}, State: {target.state}"
            )
            if target.chipset_name == target_name:
                target_id = target.target_id
    else:
        print(
            f"Get list of targets failed with error code {targets_response.status_code} {targets_response.content.decode('utf-8')}"
        )

    if target_id is not None:
        print(f"Target id for {target_name} is {target_id}")
        return target_id
    print(f"Cannot find target for {target_name}, exit.")
    return None


def submit_job(
    public_api_client,
    target_id,
    job_name,
    external_job_id,
    job_type,
    job_mode,
    timeout,
    test_framework,
    entry_script,
    job_artifacts,
    monkey_events,
    monkey_session_timeout,
    job_parameters=None,
):
    """
    Description
    -----------
        To submit a new job.

    Args
    ----
        public_api_client: QDC api client object.
        target_id: Chipset on which job needs to be executed.
        job_name: Name of the job user wanted to create.
        external_job_id: Job identifier used in external system (value is optional can be None).
        job_type: Type of the job, we have only Automated job support.
        job_mode: Mode of the job (Application, AI mode etc.). for now, we have application mode support.
        timeout: Job timeout in minutes.
        test_framework: Framework to be used for test execution (APPIUM, POWERSHELL, MONKEY, BASH).
        entry_script: Entry point script will be executed as part of test execution, mandatory for POWERSHELL test framework.
        job_artifacts: List of uploaded test artifacts to be used for test execution.
        monkey_events: number of monkey test event, needed only for monkey testframework.
        monkey_session_timeout: monkey test session timeout in minutes, needed only for monkey testframework.
        job_parameters: (optional) device configurations, set this value according to different job_type, job_mode, target_id

    Returns
    -------
        long: Newly submitted job id.
        None: In case of any failure.

    Usages
    ------
        job_name = "Sample Test Job"  # name of the job user wanted to create must be less than 32 chars
        external_job_id = "ExJobId001"  # job identifier used in external system (value is optional can be None also)
        job_type = JobType.AUTOMATED  # type of the job, we have only Automated job support
        job_mode = JobMode.APPLICATION  # mode of the job (Application, AI mode etc.). for now, we have application mode support
        timeout = 5  # job timeout in minutes
        framework = TestFramework.POWERSHELL  # framework to be used for test execution (APPIUM, POWERSHELL, MONKEY, BASH)
        entry_script = "test.ps1"  # entry point script will be executed as part of test execution, mandatory for POWERSHELL test framework
        job_artifacts = [apk_uuid, script_uuid]  # list of uploaded test artifacts to be used for test execution
            Mobile: Supported test package: apk
            Compute: Supported test package: msi, zip
            IOT/Automotive: Supported test package: zip
        monkey_events = 500 # number of monkey test event, needed only for monkey testframework.
        monkey_session_timeout = 100 # monkey test session timeout in minutes, needed only for monkey testframework.
        job_parameters = [JobSubmissionParameter.WIFIENABLED] # application scenarios of device configuration
            WifiEnabled: Valid in devices except Compute
            BluetoothEnabled: Valid in devices except Compute
            ScreenAlwaysOn: Not valid in Ubuntu OS / Automotive
            GPSEnabled: Not checked
            ProfilingEnabled: Only valid in Android OS
            RefreshEnabledBeforeJobStart: Not checked
            InstallSNPE: Only valid in Compute
            SSH ONLY: Only valid in Interactive Job

        job_id = qdc_api.submit_job(public_api_client, target_id, job_name, external_job_id, job_type, job_mode, timeout, framework, entry_script, job_artifacts, monkey_events, monkey_session_timeout, job_parameters)
    """
    if job_parameters is None:
        job_parameters = []
    job_creation_payload = CreateJobType0(
        target_id=target_id,
        job_name=job_name[:QDC_JOB_NAME_LIMIT],
        external_job_id=external_job_id,
        job_type=job_type,
        job_mode=job_mode,
        timeout_in_minutes=timeout,
        test_framework=test_framework,
        entry_script=entry_script,
        job_artifacts=job_artifacts,
        monkey_events=monkey_events,
        monkey_session_timeout=monkey_session_timeout,
        job_parameters=job_parameters,
    )
    job_creation_response = post_jobs.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client),
        body=job_creation_payload,
    )
    if job_creation_response.status_code == 200:
        print(f"Submit job response: {job_creation_response.content.decode('utf-8')}")
        assert job_creation_response.parsed is not None and hasattr(
            job_creation_response.parsed, "job_id"
        )
        job_id = job_creation_response.parsed.job_id
        print(f"Job Id: {job_id}")
        return job_id
    print(
        f"Submit a job failed with error code {job_creation_response.status_code} {job_creation_response.content.decode('utf-8')}"
    )
    return None


def get_job_status(public_api_client, job_id):
    """
    Description
    -----------
        To get the status of a given job.

    Args
    ----
        public_api_client: QDC api client object.
        job_id: Id of the job.

    Returns
    -------
        string: State of the job. like completed, canceled etc.
        None: In case of any failure.

    Usages
    ------
        job_id = "1234"
        poll_job_status = qdc_api.get_job_status(public_api_client, job_id)
        if poll_job_status.lower() == "completed":
            print("Job is completed, exiting client...")
            break
        elif poll_job_status.lower() == "canceled":
            print("Job is canceled, exiting client...")
            break
        else:
            print(f"Job is in {poll_job_status.lower()} mode")
    """
    poll_job_response = get_jobs_id.sync_detailed(
        id=job_id, client=_get_client_with_new_trace_header(public_api_client)
    )
    if poll_job_response.status_code == 200:
        response_data = poll_job_response.content.decode("utf-8")
        print(f"Job response: {response_data}")
        assert poll_job_response.parsed is not None and hasattr(
            poll_job_response.parsed, "state"
        )
        return poll_job_response.parsed.state
    return None


def get_job_log_upload_status(public_api_client, job_id):
    """
    Description
    -----------
        To get the log uploading status of a given job.

    Args
    ----
        public_api_client: QDC api client object.
        job_id: Id of the job.

    Returns
    -------
        string: State of the job log upload status. like completed, inProgress, noLogs etc.
        None: In case of any failure.

    Usages
    ------
        job_id = "1234"
        log_upload_status = qdc_api.get_job_log_upload_status(public_api_client, job_id)
        print(f"Job log upload status is in {log_upload_status.lower()}")
    """
    poll_job_response = get_jobs_id.sync_detailed(
        id=job_id, client=_get_client_with_new_trace_header(public_api_client)
    )
    if poll_job_response.status_code == 200:
        response_data = poll_job_response.content.decode("utf-8")
        print(f"Job response: {response_data}")
        assert poll_job_response.parsed is not None and hasattr(
            poll_job_response.parsed, "log_upload_status"
        )
        return poll_job_response.parsed.log_upload_status
    return None


def get_jobs_list(public_api_client, page_number, page_size):
    """
    Description
    -----------
        To get the paginated list of submitted jobs by user.

    Args
    ----
        public_api_client: QDC api client object.
        page_number: The specific page or subset of data in the context of the larger data set.
        page_size: The number of records returned in each subset of data (or “page”).

    Returns
    -------
        object: Response contains the paginated list of job information submitted by user like job created timestamp,
        job completed timestamp, job id, job submitter username, job state, etc.
        None: In case of any failure.

    Usages
    ------
        page_number = 0
        page_size = 20

        jobs = qdc_api.get_jobs_list(public_api_client, page_number, page_size)  # To get the paginated list of the submitted jobs
    """
    jobs = get_jobs.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client),
        page_number=page_number,
        page_size=page_size,
    )
    if jobs.status_code == 200:
        response_data = jobs.content.decode("utf-8")
        print(f"Getjobs response: {response_data}")
        return jobs.parsed
    return None


def abort_job(public_api_client, job_id):
    """
    Description
    -----------
        To abort submitted job.

    Args
    ----
        public_api_client: QDC api client object.
        job_id: Job id which needs to be aborted.

    Returns
    -------
        string: State of the job id.
        None: In case of any failure.

    Usages
    ------
        job_id = "1234"
        abort_job = qdc_api.abort_job(public_api_client, job_id)
    """
    abort = post_jobs_job_id_abort.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client), job_id=job_id
    )
    if abort.status_code == 200:
        response_data = abort.content.decode("utf-8")
        print(f"Abortjob: {job_id} is successful, response: {response_data}")
        assert abort.parsed is not None and hasattr(abort.parsed, "result")
        return abort.parsed.result
    return None


def submit_session(
    public_api_client,
    target_id,
    session_name,
    timeout,
    session_mode=None,
    session_artifacts=None,
    session_parameters=None,
    ssh_public_key_id=None,
):
    """
    Description
    -----------
        To submit a new session.

    Args
    ----
        public_api_client: QDC api client object.
        target_id: Chipset on which session needs to be executed.
        session_name: Name of the session user wanted to create.
        timeout: Session timeout in minutes.
        session_mode: Mode of the session (Application, AI mode etc.). for now, we have application mode support. Default mode is Application.
        session_artifacts: List of uploaded test artifacts to be used for test execution.
        session_parameters: (optional) device configurations, set this value according to different session_type, session_mode, target_id
        ssh_public_key_id: Only need for Interactive SSH connection.

    Returns
    -------
        long: Newly submitted session id.
        None: In case of any failure.

    Usages
    ------
        session_device_target = "SM8650" # device target chipset
        session_target_id = qdc_api.get_target_id(public_api_client, session_device_target)

        session_id = qdc_api.submit_session(public_api_client=public_api_client,
                                            target_id=session_target_id,
                                            session_name="Example session",
                                            timeout=600)
    """
    if session_parameters is None:
        session_parameters = []

    if session_mode is None:
        session_mode = SessionMode.APPLICATION

    session_creation_payload = CreateSessionType0(
        target_id=target_id,
        session_name=session_name,
        session_mode=session_mode,
        timeout_in_minutes=timeout,
        session_artifacts=session_artifacts,
        session_parameters=session_parameters,
        ssh_public_key_id=ssh_public_key_id,
    )

    session_creation_response = post_sessions.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client),
        body=session_creation_payload,
    )

    if session_creation_response.status_code == 200:
        print(
            f"Submit session response: {session_creation_response.content.decode('utf-8')}"
        )
        assert session_creation_response.parsed is not None and hasattr(
            session_creation_response.parsed, "session_id"
        )
        session_id = session_creation_response.parsed.session_id
        print(f"Session Id: {session_id}")
        return session_id
    print(
        f"Submit a session failed with error code {session_creation_response.status_code} {session_creation_response.content.decode('utf-8')}"
    )
    return None


def get_sessions_list(public_api_client, page_number, page_size):
    """
    Description
    -----------
        To get the paginated list of submitted interactive sessions by user.

    Args
    ----
        public_api_client: QDC api client object.
        page_number: The specific page or subset of data in the context of the larger data set.
        page_size: The number of records returned in each subset of data (or “page”).

    Returns
    -------
        object: Response contains the paginated list of session information submitted by user like session created timestamp,
        session completed timestamp, session id, session submitter username, session state, etc.
        None: In case of any failure.

    Usages
    ------
        page_number = 0
        page_size = 20

        sessions = qdc_api.get_sessions_list(public_api_client, page_number, page_size)  # To get the paginated list of the submitted sessions
    """
    sessions = get_sessions.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client),
        page_number=page_number,
        page_size=page_size,
    )
    if sessions.status_code == 200:
        response_data = sessions.content.decode("utf-8")
        print(f"Get sessions response: {response_data}")
        return sessions.parsed
    return None


def complete_session(public_api_client, session_id):
    """
    Description
    -----------
        To end a submitted session.

    Args
    ----
        public_api_client: QDC api client object.
        session_id: Session id which needs to be completed.

    Returns
    -------
        string: State of the session id.
        None: In case of any failure.

    Usages
    ------
        session_id = "1234"
        complete_session = qdc_api.complete_session(public_api_client, session_id)
    """
    complete = post_sessions_session_id_complete.sync_detailed(
        client=_get_client_with_new_trace_header(public_api_client),
        session_id=session_id,
    )
    if complete.status_code == 200:
        response_data = complete.content.decode("utf-8")
        print(f"Complete session: {session_id} successfully, response: {response_data}")
        assert complete.parsed is not None and hasattr(complete.parsed, "result")
        return complete.parsed.result
    return None


def get_session_by_id(public_api_client, session_id):
    """
    Description
    -----------
        To get the details of a given session.

    Args
    ----
        public_api_client: QDC api client object.
        session_id: Id of the session.

    Returns
    -------
        string: State of the session. like completed, canceled etc.
        None: In case of any failure.

    Usages
    ------
        session_id = "1234"
        session_by_id = qdc_api.get_session_by_id(public_api_client, session_id)
    """
    get_session_details = get_sessions_session_id.sync_detailed(
        session_id=session_id,
        client=_get_client_with_new_trace_header(public_api_client),
    )
    if get_session_details.status_code == 200:
        response_data = get_session_details.content.decode("utf-8")
        print(f"Session response: {response_data}")
        return get_session_details
    return None


def get_session_status(public_api_client, session_id):
    """
    Description
    -----------
        To get the status of a given session.

    Args
    ----
        public_api_client: QDC api client object.
        session_id: Id of the session.

    Returns
    -------
        string: State of the session. like completed, canceled etc.
        None: In case of any failure.

    Usages
    ------
        session_id = "1234"
        poll_session_status = qdc_api.get_session_status(public_api_client, session_id)
        if poll_session_status.lower() == "completed":
            print("Session is completed, exiting client...")
            break
        elif poll_session_status.lower() == "canceled":
            print("Session is canceled, exiting client...")
            break
        else:
            print(f"Session is in {poll_session_status.lower()} mode")
    """
    poll_session_response = get_sessions_session_id.sync_detailed(
        session_id=session_id,
        client=_get_client_with_new_trace_header(public_api_client),
    )
    if poll_session_response.status_code == 200:
        response_data = poll_session_response.content.decode("utf-8")
        print(f"Session response: {response_data}")
        assert poll_session_response.parsed is not None and hasattr(
            poll_session_response.parsed, "state"
        )
        return poll_session_response.parsed.state
    return None


def _get_client_with_new_trace_header(client: AuthenticatedClient | Client):
    return client.with_headers({"X-QCOM-TracingId": str(uuid.uuid4())})
